# demo-project

## Description

Demo project for technical test

## Project Structure

### Java Code

- **controllers**
- **services**
- **dao**
- **repositories**
- **entities**
- **DTO**
- **mapper**

### Resources

- **api-v1.yml**
- **application.yml**

## How to work with this project structure

1. Create endpoints definitions in file **api-v1.yml**. https://editor.swagger.io/ can be
   helpful.

2. For each **tag** related with a Swagger path, a new interface is generated in controllers
   package. _Maybe you have to run maven code-generate (or compile) phase to get the new file._

3. To implement the logic of the endpoint, create a class in **controllers** package
   which implements the interface named above.

4. The controller should map the input object (autogenerated and prefixed with "Api"),
   call a **service** method with a _domain_ object and map the result from a _domain_ object
   to an API object (autogenerated and prefixed with "Api").

5. If any new error is related with these new endpoints, create the new exception which
   describes the error and add the handling to the **ExceptionHandler**.

6. Now it's time to implement the services methods! Don't forget the **tests**!

## Important to know

- All the **endpoints should have a tag** in the Swagger definition. If no tag is specified,
  the endpoint will be declared in the DefaultApi interface. This is a bad practice because
  the name doesn't declare clearly the purpose of the endpoints in there.

- All the controllers have to implements an autogenerated interface. The application
  interface contract has to be ensured and the way is the implementation of it.
  **If a controller is created without implementing any autogenerated interface, the building
  pipeline of the CI is going to fail.**

- You can access `http://HOST/swagger-ui.html` to access the Swagger user interface
  and interact with the API directly from the browser. _Swagger UI is only active with profile
  local and dev._

- A **Clock** instance with the system default zone is created as a bean to be injected
  in the place in which a datetime is required. Injecting the clock and use the
  instance method `clock.now()` is a good practice instead of using directly the static
  method `Clock.now()`. This is because when you want to test the method, you can
  pass a mocked instance of the Clock with the datetime you want.

## About testing

- Remember that a minimum percentage of **test coverage is required**. It depends on the
  Sonar quality gate, check it to know what is the minimum one.

- It's recommended **unit testing** your solution because it's a way to avoid small bugs
  and document your code at the same time. Remember, in a unit test you only test a
  class, the interactions with other classes have to be mocked (with Mockito, for example).

- **Integration tests** are also useful. Take a example from you api-v1.yml definition and
  call your controller (using Spring MockMVC, for example). Remember, if your endpoint
  interact with DB or external components, you have to mock them (using H2 DB, for example).

## Plugins

- **openapi-generator-maven-plugin:** plugin to autogenerate the API contract structure (api model and
  controllers interface). Generally, the autogeneration of code isn't a good practice, but
  because you have to fulfil your API contract, this is the best way to ensure that
  (and you save time building the model). Bear in mind that **the model generated isn't
  the domain model and it's forbidden to use it in services or repositories**.

